#+TITLE: React Native


* absolute与zIndex与elevation
  安卓平台下，elevation会影响z轴布局
  
  https://gongchenghuigch.github.io/2018/11/10/rnAndroidPosition/

* ScrollView总结 
** 滚动到某个元素的位置
   实现的思路：
   1. 获取目标元素T在scroll里的位置P
   2. 控制scroll滚动到P

   需要用到的API：
   measure [ˈmeʒə(r)] 系列API，用来测量T在scroll里的位置

** measure系列API

   measure系列API有三个，都是可以测量元素的尺寸和位置。这些接口在获取尺寸上没有，没有任何区别，所以这里只关注位置上的区别。
   
   | API             | 位置作用                          | 具体数值                                                |
   |-----------------+-----------------------------------+---------------------------------------------------------|
   | measure         | 测量元素在RN Page和在父元素的位置 | x, y表示在父元素的位置，pageX, pageY表示在RN Page的位置 |
   | measureInWindow | 测量元素在Native屏幕中的位置      | x, y表示在Native屏幕中的位置，即便元素已经超过屏幕范围  |
   | measureLayout   | 测量元素在某个父辈元素的位置      | left, top表示在这个父辈元素中的位置                     |

   RN Page与Native 屏幕有什么区别？举例说明：当一个RN Page嵌套在一个Native页面里的时候，比如，嵌套在一个Native页面的下半部，那么这时候用
   去测量RN 页面里最上面的一个元素的位置的时候：

   + measure 测量出来的pageX, pageY都会是0。虽然它的起始位置在整个屏幕的中间，但是它相对整个RN容器的位置就是0。
   + measureInWindow 测量出来的x=0，y则应该是屏高的一半。

   
* 手势接口PanResponder
  之前写了一个轮播组件，但是轮播的内容元素的事件全被屏蔽了，翻找了一些资料之后，最后解决了。这篇[[https://juejin.cn/post/6844903434445914119][《React Native 触摸事件处理详解》]]写得非常好！

  简单总结一些RN的手势接口：
  - 一个手势是由一些列的touch、跟motion事件组成。从手指第一次touch开始，到手指离开结束
  - 元素首先通过 ~onXxxShouldSetPanResponder~ 接口来 =申请= 响应。Xxx可以是 =Start= 表示手势开始（touch），也可以是 =Move= 表示手势已经在进行中了（有时候Touch是在兄弟View开始的，然后Move进了当前View），后面不在解释Start跟Move。
  - 申请之后，onPanResponderGrant/onPanResponderReject 是申请的结果回调，表示成功或失败。
  - 如果申请成功，那么View就能通过回调onPanResponderMove被通知到手势的Move情况
  - 正常情况下，手势结束阶段会分别触发onPanResponderRelease与onPanResponderEnd两个回调，分别表示 =手势释放= 与 =手势结束=
  - 有些情况下，还会触发onResponderTerminationRequest跟onPanResponderRequestTerminal。按文档来说，是指当前View的正在响应当前的手势，这时另一个View也申请成为手势的响应者，则系统会调用onResponderTerminalRequest来询问当前View是否愿意放弃响应当前手势（因为一个手势，同时只能有一个响应者），如果同意就返回true，然后系统会调用
** 无法想到触发场景的
** 误区一：事件可以继续往后传递
  以前写web，处理web事件的时候可以调用 ~event.stopPropagation()~ 来阻止事件继续传播。但是手势事件里，貌似没有决定要不要继续传播的接口。
  现在想想这种接口肯定是没有的。因为手势事件其实是一个系列的事件，你不能已经响应了n个事件后才决定放弃响应，然后想把响应权交给其它元素。

** 大一统的“捕获冒泡”事件传播机制
  总体而言，无论是桌面操作系统、Web、iOS还是Android，其大部分事件类型的传播机制都符合“捕获

[[file:javascript.org::*DOM事件模型][DOM事件模型]]
  [[id:1F8BD8E8-31EF-4361-8673-F68C309FA4C0][DOM事件模型]]

** 现实例子：如何解决上述的轮播组件问题？
