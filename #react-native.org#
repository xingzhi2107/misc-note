#+TITLE: React Native


* absolute与zIndex与elevation
  安卓平台下，elevation会影响z轴布局
  
  https://gongchenghuigch.github.io/2018/11/10/rnAndroidPosition/

* ScrollView总结 
** 滚动到某个元素的位置
   实现的思路：
   1. 获取目标元素T在scroll里的位置P
   2. 控制scroll滚动到P

   需要用到的API：
   measure [ˈmeʒə(r)] 系列API，用来测量T在scroll里的位置

** measure系列API

   measure系列API有三个，都是可以测量元素的尺寸和位置。这些接口在获取尺寸上没有，没有任何区别，所以这里只关注位置上的区别。
   
   | API             | 位置作用                          | 具体数值                                                |
   |-----------------+-----------------------------------+---------------------------------------------------------|
   | measure         | 测量元素在RN Page和在父元素的位置 | x, y表示在父元素的位置，pageX, pageY表示在RN Page的位置 |
   | measureInWindow | 测量元素在Native屏幕中的位置      | x, y表示在Native屏幕中的位置，即便元素已经超过屏幕范围  |
   | measureLayout   | 测量元素在某个父辈元素的位置      | left, top表示在这个父辈元素中的位置                     |

   RN Page与Native 屏幕有什么区别？举例说明：当一个RN Page嵌套在一个Native页面里的时候，比如，嵌套在一个Native页面的下半部，那么这时候用
   去测量RN 页面里最上面的一个元素的位置的时候：

   + measure 测量出来的pageX, pageY都会是0。虽然它的起始位置在整个屏幕的中间，但是它相对整个RN容器的位置就是0。
   + measureInWindow 测量出来的x=0，y则应该是屏高的一半。

   
* 手势接口PanResponder
  之前写了一个轮播组件，但是轮播的内容元素的事件全被屏蔽了，翻找了一些资料之后，最后解决了。这篇[[https://juejin.cn/post/6844903434445914119][《React Native 触摸事件处理详解》]]写得非常好！ 

** 误区一：事件可以继续往后传递
  以前写web，处理web事件的时候可以调用 ~event.stopPropagation()~ 来阻止事件继续传播。但是手势事件里，貌似没有决定要不要继续传播的接口。
  现在想想这种接口肯定是没有的。因为手势事件其实是一个系列的事件，你不能已经响应了n个事件后才决定放弃响应，然后想把响应权交给其它元素。

** 大一统的“捕获冒泡”事件传播机制
  总体而言，无论是桌面操作系统、Web、iOS还是Android，其大部分事件类型的传播机制都符合“捕获

** 现实例子：如何解决上述的轮播组件问题？
