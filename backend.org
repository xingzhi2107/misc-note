#+TITLE: 后端杂项

* 如何打好日志
  看了很多篇关于如何打日志的博客，记录如下：
** 日志分级
** 哪些地方打日志？
   - 与其它子系统打交道时
   - 访问资源时
   - try-cache
   - 重要的状态变更处
   - 重要的函数入口、出口
   - 系统初始化
   - 重要业务逻辑

** 一条日志的组成部分
   - 基础信息：如哪个系统、哪个用户、哪个请求、哪个线程等
   - 描述: 发生了什么？
   - 上下文：相关的重要上下文变量
   - 如果是异常，带上track

** 打日志的禁忌
   - 到处乱打，不利于找日志，且影响性能
   - 分级不对
** 博客的连接
   [[http://www.cnblogs.com/luguo3000/p/3543487.html]]
   [[http://macrochen.iteye.com/blog/1399082]]
   [[http://www.importnew.com/28024.html]]
   [[http://www.infoq.com/cn/articles/why-and-how-log]]
   [[http://tech.lede.com/2017/06/30/rd/server/loggingHabit/]]

* nginx proxy header
  nginx proxy会不会默认转发所有header我不知道。但是，它一定不会转发带有下划线的header。
  我今天就被这个坑到了，谁会想到“下划线”不是合法的header名字？老天爷～ 然后原本好好的，上了nginx转发之后，就挂了。

  在fix这个问题的时候，我看到，自己实现这个逻辑的时候，auth token的header name竟然还支持配置。当时真的是多此一举。而且还半途而废，因为后端可以配置了，而前端却没有跟着配置走，是hardcode的。估计当时写前端的时候，也觉得自己脑子瓦特了，所以就半途而废了。

* api接口设计之“状态码”
  api的状态码应该使用"Http Status Code"，还是应该自己另行设计？这是我一直困惑、纠结的问题。今天又逛了几篇博文，看了几家大厂的api文档，排除了我的纠结。

  为什么不使用“Http Status Code”？Restful API那套设计规范看着是很优雅～ 但是用起来的时候却觉得很纠结。一个表单提交，数据validate不通过到底该报什么错？ =400 Bad Request= ？似乎是可行的，但是如果这种validate带有比较复杂的业务逻辑的时候，400，这个code貌似就很无力了。例如，“验证码超时了”。这时候，前端要做的是提醒用户，然后用户点击重发验证码，重填，然后重现提交。如果后端也是只返回400，那么前端要如何知道 到底是 表单的其它字段错了，还是验证码超时，需要重发重填？你当然不能通过比较错误message来判断，因为错误message，本质上是一种“label”，它很可能需要直接显示给用户，遇到i18问题的时候，不就挂了吗？再者，用message去进一步判断的做法，本质上不就是自己另行设计了一套“错误状态码”吗？而且是很丑陋的“错误状态码”。
  类似上面的case其实还有很多，例如知乎的[[https://www.zhihu.com/question/58686782][这篇]]讨论。很多时候，我不知道该把某个错误用什么Http状态码来表示，有时候又同时有多个状态码可以表示这个错误。我觉得HttpStatus Code的问题真是在于，它不是为描述业务逻辑而设计的。

  世界是“不完美”的，以前刚看Restful API的时候，天天为着不知如何“完全符合”Restful API标准而头痛，现在倒是觉得实用更重要。什么标准，什么规范，可以吸取，而不能生搬硬套，不切实际。定制规范的人，估计没考虑到你的case。

** 相关阅读

*** [[https://coolshell.cn/articles/22173.html][“一把梭：REST API 全用 POST”]]
  这篇我读过很多遍，底下的评论也看过几次。

#+begin_quote
RESTFul接口是适合对资源进行操作。
业务上，第一种情况，如果对外接口大都是对资源进行增删改查等操作，适合用RESTFul，当然也就比较适合使用文章中说的那些原则。
第二种情况，如果对外接口大都是复杂的业务操作，并不是对资源的增删改查，那么不适合RESTFul接口，换句话说，就是不适合生硬的套用RESTFul接口的那套原则。

另外，如果是把HTTP协议作为低层的承载协议，那就不要跟业务扯上很多关系了。HTTP就负责HTTP层面的事儿。那么很多时候，PUT、DELETE等动词就是用不上的。这时候POST一把梭哈也没什么不可以。典型的例如SOAP RPC。

#+end_quote

这个观点我比较赞同，复杂逻辑的API真不是Restful能承载的。

** 思考于 2023-03-28

*** 阅读 [[https://www.zhihu.com/question/340009165][为什么微服务返回值都包装一层？ - 黄勇的回答 - 知乎]]
  我突然想到，是不是有必要有全局唯一的error code？对于简单接口，是否可以直接返回-1以及error message即可？而对于接收端需要根据不同的error做不同的处理时，则需要有全局唯一的error code？可以实践一下。大概方案是：
  - 内部系统，简单接口只需要-1 + error message即可
  - 给外部使用的接口，则需要全局唯一的error code
  
*** service层的接口能否相互调用？
