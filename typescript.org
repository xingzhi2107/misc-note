#+TITLE: TypeScript Examples

* mapped type object
  场景：
  有时候会有这样定一个系列的string type
  #+BEGIN_SRC typescript
type Modes = 'tag' | 'name' | 'author';
  #+END_SRC
  然后需要又需要以这些合法的=Modes=为key，生成一个objct。但是，如何保证object只有这些key呢？

  这时候就需要用到mapped type object，写法如下：
  #+BEGIN_SRC typescript
type TheMapYouWant = {
  [key in Modes]: string; // 假设value类型是string
}
  #+END_SRC

  总是犯的错。每当我想写出上面的结果的时候，总是会写成indexd type：
  #+BEGIN_SRC typescript
type TheMapYouWant = {
  [key: Modes]: string; // 假设value类型是string
}
  #+END_SRC

  
* 如何简化react hoc函数的类型？
  今天研究了下怎么集成mobx，发现hoc还是比较好写的。第三方自带的hoc往往都非常的复杂，以至于有时候没有办法正常的使用，抑或会有类型丢失或者性能问题。
  在集成mobx的时候，我显示参照之前写的一个hoc写的。但是发现并不完美，需要手动提供Props跟InjectProps，我之前也是这么用的，但是这次想优化一下。于是就参照jss的withStyles写了一个版本。虽然解决了前面的问题，但是发现性能变差了，以至于调用组件的地方没办法自动补全OwnProps。我一开始以为是我抄得有问题，但是很快发现是withStyles的那种写法只要有两个hoc连着用，性能就非常差。
  我决定简化hoc的类型说明。其实hoc就是给组件注入一些props，我称之为InjectProps。只不过这些props有的是动态的，有的则是固定的。所以hoc的类型输入就是任意的组件=Com<Props>=，经过hoc作用之后，得到一个新的组件=Wrapped<Omit<Props, InjectProps>>=，这个新的组件就不需要再传入InjectProps了。基于此，我写了两个简单的hoc包装函数，这样用起来就非常的舒服，不用提供Props跟InjectProps，同时性能也不错。
  具体代码参见这个[[https://github.com/xingzhi2107/opassword/commit/4f7abaab59bd3d03d8e64edc8a942d7ea5208bad][commit]]。

* Record的高级用法
  用jss的时候，经常会苦恼class的prop提示跟styles的提示无法兼得。看了[[https://stackoverflow.com/questions/49538199/is-it-possible-to-infer-the-keys-of-a-record-in-typescript][这篇]]问答之后，豁然开朗！真是神器。
  
  #+begin_src typescript
function createStyles<T extends Styles>(cfg: T) {
  return cfg;
}

const styles = createStyles({
  footer: {
    borderTop: [1, 'solid', '#eee'],
    height: 50,
    textAlign: 'center',
  },
});

class PageFooter extends PureComponent<Props, State> {
  render() {
    const { classes } = this.props;
    return <Footer className={classes.footer}>{'Glow AdminDash'}</Footer>;
  }
}
  #+end_src

  用了createStyles这个helper函数之后，footer里面的key是类型完整的，而且classes.footer也是类型完整的。

* 错误处理库 -- true-myth
  今天看到这篇[[https://journal.plain.com/posts/2022-10-04-error-handling-in-typescript-like-a-pro/][Error handling in TypeScript like a pro]]，突然眼前一亮。true-myth的Result简直跟rust一模一样。感觉这样能解决TS里一个函数调用，error不可知的问题。以后可以试试。话说python3的type hint能实现类型的功能吗？

* assertion语句
 [[https://blog.logrocket.com/assertion-functions-typescript/][Assertion functions in TypeScript]]

 assertion函数蛮有用的。有时候你需要写一些数值校验函数，如果值通过了校验，一般可以确定值的是某种（些）类型。

* 什么时候需要定义return type？
  [[https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#return-type-annotations][官方]]是这样说的：
#+begin_quote 
Much like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on its return statements. The type annotation in the above example doesn’t change anything. Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference.
#+end_quote
 
  如官方所说，个人也认为大部分情况下是可以忽略return type，让TS推导即可。但是大概有三种情况是需要自己写return type：
  1. 写库函数、对外接口时。出于严肃，这些场景下要特别标明返回类型。
  2. TS自动推导的类型，不符合你的预期。比如，你写下一个函数返回字符串 "abc"，这时候TS自动推导这个函数的返回值类型是string。但是你预期这个函数只能返回 "abc" | "hello" | "world"等几个有限的类型。
  3. 函数的内部结构比较复杂时。这时候标明你预期的return type，能够避在写实现这个复杂函数的时候，迷失了预期的返回值类型。

  参见：
  [[https://stackoverflow.com/questions/70001511/why-specify-function-return-types][Why specify function return types?]]
  [[https://www.totaltypescript.com/tips/dont-use-return-types-unless][Don't use return types, unless...]]


* interface与type的区别？
  我一直不理解已经有type了，为什么TS官网还要提供interface关键字？可能只是为了语义化，可能interface更倾向于描述结构化的对象。不得而知！

  回归主题，二者有什么区别？有那么一点，但是无关紧要：
  1. interface无法给另一个类型其别名，而type可以;
  2. interface可以重复声明，合并props但是type可以；

  正如[[https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces][官方]]所说的那样：
  #+begin_quote
If you would like a heuristic, use interface until you need to use features from type.
  #+end_quote
  反正优先使用interface即可，搞不定再用type。至于二者有什么区别，就不用去关心了。

* 面量的类型推导 -- Literal type and literal interface
  重新看了TS的文档，才发现自己遗漏了一些面量类型推导的细节。

** let与const的区别

#+begin_src typescript
  let s = 'hello';   // 推导出来s的类型是string, 因为是let声明的变量，说明后续可能会变
  const s2 = 'hello';  // 推导出来s的类型是'hello', 因为是用const声明的变量，后续已经不可能会变
#+end_src


** as const用法
  声明对象的时候，默认推导出来的属性类型都是尽量泛化的，如下：

#+begin_src typescript
  const obj = {
      name: 'hello',
      age: 17,
  }   // obj.name的类型是string, obj.age的类型是number
#+end_src

  但是有些时候，你希望默认推导出来的类型是面量，可以用 as const

#+begin_src typescript
  const obj = {
      name: 'hello',
      age: 17,
  } as const   // obj.name的类型是'hello', obj.age的类型是 17
#+end_src


* 类型标记
  类似早期的静态强类型语言，TS可以给变量加上类型符号来限制变量的类型，举几个例：

#+begin_src typescript
// 限制变量name只能是string类型
let name: string;


// 先用type关键字定义一个类型 -- ButtonProps
type ButtonProps  = {

  // 必填字段，类型为string
  title: string;

  // 问号表示可选字段，类型为 'small' 或者 'middle' 或者 'large'，这是一个Union Type
  size?: 'small' | 'middle' | 'large';

  // 同上为可选字段，同样是一个Union Type
  loading?: boolean | {delay: number};
}
// 限制变量prop只能是ButtonProps类型
let prop: ButtonProps;


// 限制函数sum的三个参数都要是number类型，最后一个参数的问号表示可以这个参数省略
// 结尾的number限制函数需要返回一个number类型
function sum(first: number, second: number, third?: number): number {}
#+end_src

  这样写又太麻烦了，所以一般只有如下几种情况会去显示标明类型：
  1. 写数据entry定义、接口定义的时候；
  2. 变量先声明，后初始化的时候；
  3. TS自动推导出的类型，只是其中一种情况，需要coder显示标明出所有允许的类型；
  4. 函数的参数必须显示标明类型（同情况1），但是返回类型一般也无需显示标明，除非：
     a. 声明接口时，这时候没有面量上下文可供TS推导；
     b. 函数内部的分支多、实现逻辑复杂时，显示标明返回类型，免得自己写错逻辑；

  其余情况下基本是让TS自己基于面量上下文自动做类型推导。
  
* 基于面量的类型推导
  TS会根据面量上下文自动推导出变量的类型、函数的返回类型。

#+begin_src typescript
let name1 = 'Harry';    // 自动推导为string类型
const name2 = 'Harry'; // 自动推导为'Harry'，这是为什么？
let name3 = 'Harry' as const;   // 同样推导为'Harry', 为什么？


// obj1跟obj2都自动推导为：
// {name: string; age: number;}
let obj1 = {
  name: 'Harry',
  age: 17,
};
const obj2 = {
  name: 'Harry',
  age: 17,
};

// 而obj3则推导为
// {name: 'Harry'; age: 17;}
let obj3 = {
  name: 'Harry',
  age: 17,
} as const;


// arr1推导为 (string | number)[];
const arr1 = ['Harry', 17];

// 而arr2则推导为 readonly ['Harry', 17]，这是tuple类型
const arr2 = ['Harry', 17] as const;
#+end_src

  TS根据面量上下文推导的时候，大概有两种推导方式：
  1. let推导，宽泛推导，即尽量往更宽的范围去根据面量值来推导类型。例如name1、obj1、obj2、arr1的推导方式，
  2. const推导，精准推导，基本你写了什么它就是什么类型。例如name2、name3、obj3、arr2的推导方式

  说到这里，应该就知道值后面的as const的作用是什么了吧？

  对于复合数据结构Array、Object，无论是用const还是let声明的变量：
  1. 其key的推导只有const推导;
  2. 其value的推导默认是let推导，可以用as const显示采用const推导；

  上诉的规则同样适用于函数的返回值。多个return的函数，多种推导结果会组成一个Union Type。

  一般情况下我们都不用在意它是let推导还是const推导，基本是无感知的。因为一个const变量，没有本来就没有变的可能，而得益于类型兼容，name1 = name2 这样的赋值又是完全合法的。

* Type与Value之间的三八线
  TS经过编译之后就是JS代码。也就是TS所附加的所有类型（Type）都会被清除，只留下“值（Value）”。这里的Value是一个很广义的概念，大概可以说属于JS的都叫值。原始值、对象、数组（本质是对象）、函数（本质也是对象）、class（本质也是对象）等等都是值。
  在TS里，Type跟Value有很严格的分界线，二者不可混用。只不过为了方便，TS给一些Value默认赋予了同名的Type，如面量原始值、class。所以你可以有如下的使用方式：

#+begin_src typescript
// 冒号后面的这些'age', 'name', 3, false都是合法的js面量值，但是它们在这里表示的Type而不是Value
let a: 'age' | 'name' | 3 | false = false;


class A {
  public name = 'Harry';
}

// 冒号后面的A是合法的js class，但是它在这里表示的是Type而不是Value
let a: A = new A();
  
#+end_src

  当不存在同名Type与Value的时候，你就能清晰的“看到”这条分界线，举两个例子：

#+begin_src typescript
// 例子一：尝试把Value当Type使用
function hello(name: string) {
  return `Hello, ${name}`;
}
// 我们希望再写一个箭头函数，使其类型与 hello 一致
let b: hello = (name: string) => {  // 报错：TS2749: 'hello' refers to a value, but is being used as a type here. Did you mean 'typeof hello'?
  return `Hi, ${name}`;
};


// 例子二：尝试把Type当Value使用

// 复用上面的class A定义，把它放在文件A.ts里，然后在另一个文件里用import type只导入它的类型
import type {A} from './A';

// TS1361: 'A' cannot be used as a value because it was imported using 'import type'.
let a: A = new A();  
#+end_src

  从例子一的报错提示就可以知道，我们可以用typeof Value来提取这个Value的Type。所以例一改成 `let b: typeof hello...省略` 即可。但是反过来不行，TS没有提供根据Type来生成Value的方法（最好也别提供）。

  这里再说一下TS的操作符。TS有一些类型操作符跟JS的一模一样的，但是切记，它们作用于Type的时候与JS里作用与Value的时候含义不一样。我想这也是TS容易让人混淆Type与Value的关系的原因。举几个例子 ：
  - typeof 在TS里是用来提取一个面量Value的Type，而JS里是返回一直值的字符串类型描述
  - A | B 表示Union Type，而JS里是位运算或
  - A & B 表示合并两个类型，而JS里是位运算与
  - T extends B 表示限定泛型参数A必须兼容类型B，而JS里是class继承的关键字
  
  
* 从面量对象提取对象keys的Union Type
  这个很简单，也很常用。就是用[[https://www.typescriptlang.org/docs/handbook/2/typeof-types.html][keyof运算符]]来提取面量对象的类型的peoperties。

#+begin_src typescript
const size2Source = {
    16: require('./16.png'),
    24: require('./24.png'),
    32: require('./32.png'),
};

interface IconPencilProps {
    tintColor?: string;
    size: keyof (typeof size2Source);  // size的类型就是 16 | 24 | 32，是一个Union Type。这里的括号仅为了阅读方便，可以省略。
}

const a: IconPencilProps = {
  size: 64, // 报错： TS2322: Type '64' is not assignable to type '16 | 24 | 32'.
};  
#+end_src

  往后当这个组件支持新尺寸的时候，修改size2Source对应props里的size的类型

* 从面量对象提取对象values的Union Type (*)


* 从面量数组提取数组值的Union Type
