#+TITLE: TypeScript Examples

* mapped type object
  场景：
  有时候会有这样定一个系列的string type
  #+BEGIN_SRC typescript
type Modes = 'tag' | 'name' | 'author';
  #+END_SRC
  然后需要又需要以这些合法的=Modes=为key，生成一个objct。但是，如何保证object只有这些key呢？

  这时候就需要用到mapped type object，写法如下：
  #+BEGIN_SRC typescript
type TheMapYouWant = {
  [key in Modes]: string; // 假设value类型是string
}
  #+END_SRC

  总是犯的错。每当我想写出上面的结果的时候，总是会写成indexd type：
  #+BEGIN_SRC typescript
type TheMapYouWant = {
  [key: Modes]: string; // 假设value类型是string
}
  #+END_SRC

  
* 如何简化react hoc函数的类型？
  今天研究了下怎么集成mobx，发现hoc还是比较好写的。第三方自带的hoc往往都非常的复杂，以至于有时候没有办法正常的使用，抑或会有类型丢失或者性能问题。
  在集成mobx的时候，我显示参照之前写的一个hoc写的。但是发现并不完美，需要手动提供Props跟InjectProps，我之前也是这么用的，但是这次想优化一下。于是就参照jss的withStyles写了一个版本。虽然解决了前面的问题，但是发现性能变差了，以至于调用组件的地方没办法自动补全OwnProps。我一开始以为是我抄得有问题，但是很快发现是withStyles的那种写法只要有两个hoc连着用，性能就非常差。
  我决定简化hoc的类型说明。其实hoc就是给组件注入一些props，我称之为InjectProps。只不过这些props有的是动态的，有的则是固定的。所以hoc的类型输入就是任意的组件=Com<Props>=，经过hoc作用之后，得到一个新的组件=Wrapped<Omit<Props, InjectProps>>=，这个新的组件就不需要再传入InjectProps了。基于此，我写了两个简单的hoc包装函数，这样用起来就非常的舒服，不用提供Props跟InjectProps，同时性能也不错。
  具体代码参见这个[[https://github.com/xingzhi2107/opassword/commit/4f7abaab59bd3d03d8e64edc8a942d7ea5208bad][commit]]。

* Record的高级用法
  用jss的时候，经常会苦恼class的prop提示跟styles的提示无法兼得。看了[[https://stackoverflow.com/questions/49538199/is-it-possible-to-infer-the-keys-of-a-record-in-typescript][这篇]]问答之后，豁然开朗！真是神器。
  
  #+begin_src typescript
function createStyles<T extends Styles>(cfg: T) {
  return cfg;
}

const styles = createStyles({
  footer: {
    borderTop: [1, 'solid', '#eee'],
    height: 50,
    textAlign: 'center',
  },
});

class PageFooter extends PureComponent<Props, State> {
  render() {
    const { classes } = this.props;
    return <Footer className={classes.footer}>{'Glow AdminDash'}</Footer>;
  }
}
  #+end_src

  用了createStyles这个helper函数之后，footer里面的key是类型完整的，而且classes.footer也是类型完整的。

* 错误处理库 -- true-myth
  今天看到这篇[[https://journal.plain.com/posts/2022-10-04-error-handling-in-typescript-like-a-pro/][Error handling in TypeScript like a pro]]，突然眼前一亮。true-myth的Result简直跟rust一模一样。感觉这样能解决TS里一个函数调用，error不可知的问题。以后可以试试。话说python3的type hint能实现类型的功能吗？

* assertion语句
 [[https://blog.logrocket.com/assertion-functions-typescript/][Assertion functions in TypeScript]]

 assertion函数蛮有用的。有时候你需要写一些数值校验函数，如果值通过了校验，一般可以确定值的是某种（些）类型。

* 什么时候需要定义return type？
  [[https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#return-type-annotations][官方]]是这样说的：
#+begin_quote 
Much like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on its return statements. The type annotation in the above example doesn’t change anything. Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference.
#+end_quote
 
  如官方所说，个人也认为大部分情况下是可以忽略return type，让TS推导即可。但是大概有三种情况是需要自己写return type：
  1. 写库函数、对外接口时。出于严肃，这些场景下要特别标明返回类型。
  2. TS自动推导的类型，不符合你的预期。比如，你写下一个函数返回字符串 "abc"，这时候TS自动推导这个函数的返回值类型是string。但是你预期这个函数只能返回 "abc" | "hello" | "world"等几个有限的类型。
  3. 函数的内部结构比较复杂时。这时候标明你预期的return type，能够避在写实现这个复杂函数的时候，迷失了预期的返回值类型。

  参见：
  [[https://stackoverflow.com/questions/70001511/why-specify-function-return-types][Why specify function return types?]]
  [[https://www.totaltypescript.com/tips/dont-use-return-types-unless][Don't use return types, unless...]]


* interface与type的区别？
  我一直不理解已经有type了，为什么TS官网还要提供interface关键字？可能只是为了语义化，可能interface更倾向于描述结构化的对象。不得而知！

  回归主题，二者有什么区别？有那么一点，但是无关紧要：
  1. interface无法给另一个类型其别名，而type可以;
  2. interface可以重复声明，合并props但是type可以；

  正如[[https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces][官方]]所说的那样：
  #+begin_quote
If you would like a heuristic, use interface until you need to use features from type.
  #+end_quote
  反正优先使用interface即可，搞不定再用type。至于二者有什么区别，就不用去关心了。

* 面量的类型推导
